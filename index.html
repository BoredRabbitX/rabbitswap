<script>
    // PARAMETRI UFFICIALI PASEO ASSET HUB
    const PASEO_CHAIN_ID = "0x190bc416"; // 420420422 in Hex
    const PASEO_PARAMS = {
        chainId: PASEO_CHAIN_ID,
        chainName: 'Paseo Asset Hub',
        nativeCurrency: { name: 'PAS', symbol: 'PAS', decimals: 18 },
        rpcUrls: ['https://testnet-passet-hub-eth-rpc.polkadot.io'], // RPC Ufficiale Polkadot
        blockExplorerUrls: ['https://blockscout-passet-hub.parity-testnet.parity.io']
    };

    const HOP_ADDR = "0x5bF234923b9A947Ad6770DAD18A04F9ae33AD3Bc";
    const SWAP_ADDR = "0x73bde75a9b1E0a13B76624A51371f78FE579d478";
    const OWNER = "0xa036B32c86E2aB7F2AdE9ACC15984B2A2DDe8977";

    let provider, signer, hopCtx, swapCtx, user;

    async function initConnection() {
        if (!window.ethereum) return updateLog("ERROR: METAMASK_NOT_FOUND");
        
        try {
            const chainId = await window.ethereum.request({ method: 'eth_chainId' });
            
            // Se la rete è sbagliata, mostriamo il tasto switch
            if (chainId.toLowerCase() !== PASEO_CHAIN_ID.toLowerCase()) {
                document.getElementById('btn-connect').style.display = 'none';
                document.getElementById('btn-switch').style.display = 'inline-block';
                updateLog("WRONG_NETWORK: SWITCH TO PASEO ASSET HUB");
                return;
            }

            // Se la rete è corretta, procediamo con la connessione
            provider = new ethers.providers.Web3Provider(window.ethereum);
            await provider.send("eth_requestAccounts", []);
            signer = provider.getSigner();
            user = await signer.getAddress();

            setupContracts();
            showInterface();
        } catch (e) { 
            console.error(e);
            updateLog("CONNECTION_REJECTED"); 
        }
    }

    async function switchNetwork() {
        try {
            await window.ethereum.request({
                method: 'wallet_switchEthereumChain',
                params: [{ chainId: PASEO_CHAIN_ID }],
            });
            location.reload();
        } catch (switchError) {
            // Se la rete non è presente in MetaMask, la aggiungiamo
            if (switchError.code === 4902) {
                try {
                    await window.ethereum.request({
                        method: 'wallet_addEthereumChain',
                        params: [PASEO_PARAMS],
                    });
                } catch (addError) { 
                    updateLog("FAILED_TO_ADD_NETWORK"); 
                }
            }
        }
    }

    function setupContracts() {
        // ABI minime per far funzionare i moduli
        const abiH = [
            "function balanceOf(address) view returns (uint256)",
            "function claimToken() external",
            "function lastClaim(address) view returns (uint256)",
            "function approve(address,uint256) returns (bool)",
            "function sendToContract(address,uint256) external"
        ];
        const abiS = [
            "function swapHOPxforRABx(uint256 nIn) external",
            "function mintRABx(uint256 n) external"
        ];
        
        hopCtx = new ethers.Contract(HOP_ADDR, abiH, signer);
        swapCtx = new ethers.Contract(SWAP_ADDR, abiS, signer);
    }

    // ... Resto delle funzioni (updateStatus, refreshBal, runApprove, runSwap, runClaim, etc.)
    // Mantieni le funzioni del codice v1.4 precedente.
</script>
